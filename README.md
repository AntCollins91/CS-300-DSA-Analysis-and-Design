# CS-300-DSA-Analysis-and-Design

In this journal entry, I am submitting artifacts from two projects for my portfolio, demonstrating my understanding and application of data structures and algorithms. From Project One, I am including my analysis of run-time and memory usage for various data structures. From Project Two, I am submitting the working code that sorts and prints out a list of Computer Science courses in alphanumeric order. These artifacts showcase my skills in optimizing code efficiency and applying appropriate data structures for different tasks.

Problem Solving in the Projects
The main problem I addressed in these projects involved selecting and implementing efficient data structures to manage and manipulate data effectively. In Project One, the focus was on understanding the performance implications of different data structures in terms of run-time and memory usage. Project Two required developing a solution that could sort a list of courses alphanumerically, which involved understanding the nuances of sorting algorithms and how they interact with data structures.

Approach to the Problem
I approached these problems by first analyzing the requirements and constraints of each task. For Project One, this meant examining the complexity of operations such as insertion, deletion, and searching across different data structures like arrays, linked lists, hash tables, and trees. Understanding these complexities was crucial because selecting the right data structure can significantly impact the performance and efficiency of an application. For Project Two, I leveraged sorting algorithms and chose appropriate data structures that could store and sort the course data efficiently.

Overcoming Roadblocks
While working on these projects, I encountered several challenges, particularly related to optimizing the code for better performance. One major roadblock was dealing with the trade-offs between memory usage and run-time efficiency. For instance, hash tables offer faster lookup times but at the cost of increased memory usage. To overcome these challenges, I experimented with different data structures and conducted performance profiling to understand the impact of my choices. Consulting resources, discussing with peers, and iterative testing were also critical in overcoming these roadblocks.

Expanding My Approach to Software Design and Development
These projects significantly expanded my understanding of software design and development. I learned the importance of choosing the right data structure not only for performance but also for maintainability and scalability. The hands-on experience with different algorithms and data structures reinforced the theoretical knowledge I had gained and highlighted how these concepts are crucial in real-world applications. This experience has shaped my approach to be more analytical and data-driven, ensuring that design choices are backed by solid understanding and evidence.

Evolution of Programming Practices
Working on these projects has evolved the way I write programs to be more maintainable, readable, and adaptable. I learned to write cleaner, modular code that is easier to understand and debug. Proper documentation and commenting were emphasized, making it easier for others (and myself) to understand the code at a later date. Additionally, I adopted best practices such as code refactoring and testing to ensure that the code remains adaptable to future changes. These practices not only improve the quality of the software but also make it more resilient to change, which is a valuable trait in the fast-evolving field of software development.

Conclusion
Through these projects, I have gained a deeper appreciation for the role of data structures and algorithms in software development. By solving complex problems and overcoming challenges, I have developed a stronger foundation in creating efficient, maintainable, and scalable software solutions. This experience will be invaluable as I continue to grow as a software developer and tackle more complex projects in the future.
